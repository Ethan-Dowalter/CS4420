/**
 *        @file: parser.y
 *      @author: Ethan Dowalter
 *        @date: September 27, 2021
 *       @brief: Bison parser for my bash shell
 */
 
%{
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// Checks for invalid i/o redirection and throws an error if it finds anything bad
void check_ioredir(struct io_redir *optredir);

// Takes a linked list of io_redir objects and returns the first one it finds with the right redirect type
struct io_redir *find_iofile(struct io_redir *optredir, int type);

// Moved this to bash.h because it gets used in the command struct
// struct args {
//     char *arg;
//     struct args *next;
// };


/* include debugging code, in case we want it */
#define YYDEBUG 1

int lines = 1;
static int synerrors = 0;
int errorflag = 0;


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
    struct args *pargs;
	struct io_redir *pio;
    int number;
}



%token EOLN PIPE INPUT
%token <number> OUTPUT OUTPUT_APPEND ERROUT ERROUT_APPEND
%token <string> WORD

%type <string> arg
%type <pio> optredir
%type <pcmd> line cmd
%type <pargs> args
  

%% 	/* beginning of the parsing rules	*/
input	: lines
		|
  		;

lines	: oneline
		| oneline lines
		;

oneline : line
			{
				doline($1, lines, errorflag);
			}
	  		eoln
 		| eoln	/* blank line, do nothing */
		| error eoln
		/* if we got an error on the line, don't call the C program */
		;

eoln	: EOLN
			{
				++lines;
				errorflag = 0;
			}
		;

line	: cmd
			{
				$$ = $1;
				$$->nextpipe = NULL;
			}
  		| cmd PIPE line
			{
				$$ = $1;
				$$->nextpipe = $3;

				/* Check for invalid redirects inside pipes */
				if(strcmp($1->outfile, "<undirected>") != 0)
				{
					yyerror("Cannot redirect output inside a pipe");
				}

				if(strcmp($3->infile, "<undirected>") != 0)
				{
					yyerror("Cannot redirect input inside a pipe");
				}
			}
  		;

cmd		: WORD args optredir
			{
				/* Store the command and args inside command struct */
				$$ = (struct command *) malloc(sizeof(struct command));
				$$->command = $1;
				$$->pargs = $2;

				/* Get the length of the args linked list into argc */
				struct args *current = (struct args*) malloc(sizeof(struct args));
				current = $2;
				int args_len = 1;
				while(current != NULL)
				{
					args_len++;
					current = current->next;
				}
				$$->argc = args_len;

				/* Only check for io redirection if there is any */
				if($3 != NULL)
				{
					/* Check for valid redirects */
					check_ioredir($3);

					/* Use a temporary pointer to an io_redir object to load data into command */
					struct io_redir *temp = (struct io_redir*) malloc(sizeof(struct io_redir));
					
					/* Infile */
					temp = find_iofile($3, 0);
					if(temp == NULL)
					{
						$$->infile = "<undirected>";
					}
					else
					{
						$$->infile = temp->file;
					}

					/* Outfile */
					temp = find_iofile($3, 1);
					if(temp == NULL)
					{
						/* Check for output append */
						temp = find_iofile($3, 2);
						if(temp == NULL)
						{
							$$->outfile = "<undirected>";
						}
						else
						{
							$$->outfile = temp->file;
							$$->output_append = 1;
						}
					}
					else
					{
						$$->outfile = temp->file;
						$$->output_append = 0;
					}

					/* Errfile */
					temp = find_iofile($3, 3);
					if(temp == NULL)
					{
						/* Check for error append */
						temp = find_iofile($3, 4);
						if(temp == NULL)
						{
							$$->errfile = "<undirected>";
						}
						else
						{
							$$->errfile = temp->file;
							$$->error_append = 1;
						}
					}
					else
					{
						$$->errfile = temp->file;
						$$->error_append = 0;
					}
				}
				else
				{
					$$->infile = "<undirected>";
					$$->outfile = "<undirected>";
					$$->errfile = "<undirected>";
					$$->output_append = 0;
					$$->error_append = 0;
				}
			}
		| WORD args optredir cmd
			{
				yyerror("Cannot include arguments past the optional i/o redirection");
			}
		;

args	: arg args
			{
				$$ = (struct args *) malloc(sizeof(struct args));
				$$->arg = $1;
				$$->next = $2;
			}
		|
			{ 
				$$ = NULL;
			}
		;

arg		: WORD
		;

optredir 	: INPUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 0;
					$$->file = $2;
					$$->next = $3;
				}
			| OUTPUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 1;
					$$->file = $2;
					$$->next = $3;
				}
			| OUTPUT_APPEND WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 2;
					$$->file = $2;
					$$->next = $3;
				}
			| ERROUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 3;
					$$->file = $2;
					$$->next = $3;
				}
			| ERROUT_APPEND WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 4;
					$$->file = $2;
					$$->next = $3;
				}
			|
				{
					$$ = NULL;
				}
			;

%%

void yyerror(const char *error_string, ...) {
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;
	++errorflag;
	// fprintf(f, "synerrors = %d\n", synerrors);
    fprintf(f,"Error on line %d: ", lines);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

void check_ioredir(struct io_redir *optredir){
	/// Check the linked list for invalid redirects, if there are then raise an error
	struct io_redir *current = (struct io_redir *) malloc(sizeof(struct io_redir));
	current = optredir;
	int inflag = 0;
	int outflag = 0;
	int errflag = 0;	
	while(current != NULL)
	{
		if(inflag == 0 && current->redir_type == 0)
		{
			inflag = 1;
		}
		else if(current->redir_type == 0)
		{
			yyerror("Too many input redirects!");
		}

		if(outflag == 0 && (current->redir_type == 1 || current->redir_type == 2))
		{
			outflag = 1;
		}
		else if(current->redir_type == 1 || current->redir_type == 2)
		{
			yyerror("Too many output redirects!!");
		}

		if(errflag == 0 && (current->redir_type == 3 || current->redir_type == 4))
		{
			errflag = 1;
		}
		else if(current->redir_type == 3 || current->redir_type == 4)
		{
			yyerror("Too many error redirects!!!");
		}

		current = current->next;
	}
}

struct io_redir *find_iofile(struct io_redir *optredir, int type){
	/// Walk through the linked list searching for the given type of redirect
	struct io_redir *current = (struct io_redir *) malloc(sizeof(struct io_redir));
	current = optredir;
	while(current != NULL)
	{
		if(current->redir_type == type)
		{
			return(current);
		}
		current = current->next;
	}

	return(NULL);
}