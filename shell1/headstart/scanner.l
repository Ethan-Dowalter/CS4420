%{
/**
 *        @file: scanner.l
 *      @author: Ethan Dowalter
 *        @date: September 27, 2021
 *       @brief: Flex lexical analyzer for my bash shell
 */

/*
 * Simple example lex input file
 *
 * Shawn Ostermann -- Sept 9, 2021
 *
 * Headstart version
 */

#include <string.h>
#include <ctype.h>
#include "parser.h"

/* some internal files generated by bison */
void yyerror(const char *s,...);
void yywarn(const char *s,...);


/* Everything up to the funny characters on the next line */
/* goes directly into the lex.yy.c file */
%}

/* shorthand definitions for later */
DIGIT		[0123456789]
LETTER		[a-zA-Z]
OTHERCHARS	[^\n|<>\" \t]
WHITESPACE	[ \t]
/* WEIRD BUG DO NOT USE!!! MESSES WITH INPUT CHAR DETECTION OF LESS THAN CHAR??? */
/* OTHERCHARS	[!@#$%^&*()_+-=\[\]{}\\;:',./?`~] */


/* The rest of this after the '%%' is lex rules */
/* you need rules for the other reserved characters */
/* you need a rule that returns WORD */
/* you need a rule that returns "strings" as WORDS */
%%

{WHITESPACE}+	{ }  /* Just ignore white space */

"\n" 	        { return(EOLN); }
"|"             { return(PIPE); }
"<"             { return(INPUT); }
">"             { return(OUTPUT); }
">>"            { return(OUTPUT_APPEND); }
"2>"            { return(ERROUT); }
"2>>"           { return(ERROUT_APPEND); }

({DIGIT}|{LETTER}|{OTHERCHARS})+    {
    yylval.string = strdup(yytext);  /* make a copy of the string */
    /* printf("Hello, I just saw this: %s\n", yytext); */
    return(WORD);
}

\"[^"\n]*\" {
    yytext[strlen(yytext) - 1] = 0;
    yylval.string = strdup(yytext + 1);  /* make a copy of the string */
	/* printf("String: %s\n", yylval.string); */
    return(WORD);
}

.		{
    /* if we haven't matched anything yet, then it's illegal */
    yyerror("scanner: Bad character '%c'", *yytext);
}


%%
