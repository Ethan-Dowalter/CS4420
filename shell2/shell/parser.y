/**
 *        @file: parser.y
 *      @author: Ethan Dowalter
 *        @date: October 20, 2021
 *       @brief: Bison parser for my bash shell
 */
 
%{
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <unistd.h>
#include <ctype.h>
#include "bash.h"

/* some internal files generated by bison */
int yylex();
void yyerror(const char *s,...);
void yywarn(const char *s,...);

// Checks for invalid i/o redirection and throws an error if it finds anything bad
void check_ioredir(struct io_redir *optredir);

// Takes a linked list of io_redir objects and returns the first one it finds with the right redirect type
struct io_redir *find_iofile(struct io_redir *optredir, int type);

// Takes a string in the form of 'something=something' and assigns an environment variable
void AssignVar(char *string);

// Prints the prompt for the user
void Prompt();

// Removes the enclosing quotes from a string, double or single
char *DelQuotes(char *string);

// Checks a string to see if it can expand any environment variables inside it and returns the expanded version
char *VarExpand(char *string);

// Mimics the getenv system call, but checks the global vars array instead
char *mygetenv(char *name);

// Function for executing for loops
void doForLoop(struct loopfor *myfor);

// Function for executing while loops
void doWhileLoop(struct loopwhile *mywhile);

// Same thing as VarExpand, but doesn't check for single quotes and expands variables regardless
char *VarExpand2(char *string);


/* include debugging code, in case we want it */
#define YYDEBUG 1

#define MAX_ARGS 100
#define MAX_PATHS 100
#define MAX_VARS 100

int lines = 1;
static int synerrors = 0;
int errorflag = 0;
int DEBUG = 0;
struct var vars[MAX_VARS];
int NEXT_OPEN_SPOT = 4;		// first four spots in vars array are reserved for HOME, PROMPT, DEBUG, and PATH in that order


%}


%union	{ /* the types that we use in the tokens */
    char *string;
    struct command *pcmd;
	struct metacmd *pmetacmd;
	struct metacmdlist *pmetacmdlist;
	struct loopwhile *pwhileloop;
	struct loopfor *pforloop;
    struct args *pargs;
	struct io_redir *pio;
	struct loopfor *pfor;
	struct loopwhile *pwhile;
    int number;
}



%token EOLN PIPE INPUT CD SEMICOLON FOR WHILE IN DO DONE EXPORT
%token <number> OUTPUT OUTPUT_APPEND ERROUT ERROUT_APPEND
%token <string> WORD VAR VAREXPAND 

%type <string> arg assignment chdir variable
%type <pio> optredir
%type <pcmd> line cmd
%type <pmetacmd> metacmd
%type <pmetacmdlist> metacmdlist
%type <pwhileloop> whileloop
%type <pforloop> forloop
%type <pargs> args loopargs
  

%% 	/* beginning of the parsing rules	*/
input	: lines
		|
  		;

lines	: oneline lines
		| forloop lines
		| whileloop lines
		|
		;

forloop	: FOR WORD IN loopargs eoln DO eoln metacmdlist DONE neweoln
			{
				$$ = (struct loopfor *) malloc(sizeof(struct loopfor));
				$$->variable = $2;
				$$->loopargs = $4;
				$$->body = $8;
				doForLoop($$);
				Prompt();
			}
		;

whileloop 	: WHILE cmd eoln DO eoln metacmdlist DONE neweoln
				{
					$$ = (struct loopwhile *) malloc(sizeof(struct loopwhile));
					$$->condition = $2;
					$$->body = $6;
					doWhileLoop($$);
					Prompt();
				}
			;

loopargs	: arg loopargs
				{
					$$ = (struct args *) malloc(sizeof(struct args));
					$$->arg = $1;
					$$->next = $2;
				}
			| arg
				{
					$$ = (struct args *) malloc(sizeof(struct args));
					$$->arg = $1;
					$$->next = NULL;
				}
			;

neweoln	: EOLN
			{
				++lines;
				errorflag = 0;
			}
		| SEMICOLON EOLN
			{
				++lines;
				errorflag = 0;
			}
		| SEMICOLON
			{
				errorflag = 0;
			}
		; 

oneline : chdir eoln
		| assignment eoln
		| EXPORT args variable
			{
				printf("1%s\n", $3);
    			fflush(stdout);
				struct command *mycommand = (struct command *) malloc(sizeof(struct command));
				mycommand->command = "export";
				mycommand->pargs = $2;
				struct args *current = (struct args *)malloc(sizeof(struct args));
				current = mycommand->pargs;
				mycommand->argc++;
				if (current != NULL)
				{
					while (current->next != NULL)
					{
						mycommand->argc++;
						current = current->next;
					}
					mycommand->argc++;
					current->next = (struct args *)malloc(sizeof(struct args));
					current->next->arg = $3;
					current->next->next = NULL;
					printf("%s\n", current->next->arg);
					fflush(stdout);
				}
				else
				{
					mycommand->pargs = (struct args *)malloc(sizeof(struct args));
					mycommand->pargs->arg = $3;
					mycommand->pargs->next = NULL;
					printf("2%s\n", mycommand->pargs->arg);
					fflush(stdout);
				}

				int temp = 0;
				doline(mycommand, lines, errorflag, DEBUG, &temp);
			}
			eoln
		| line
			{
				int temp = 0;			
				doline($1, lines, errorflag, DEBUG, &temp);
			}
	  		eoln
 		| eoln	/* blank line, do nothing */
		| error eoln /* if we got an error on the line, don't call the C program */
		;

eoln	: EOLN
			{
				++lines;
				errorflag = 0;
				Prompt();
			}
		| SEMICOLON EOLN
			{
				++lines;
				errorflag = 0;
				Prompt();
			}
		| SEMICOLON
			{
				errorflag = 0;
			}
		;

line	: cmd
			{
				$$ = $1;
				$$->nextpipe = NULL;
			}
  		| cmd PIPE line
			{
				$$ = $1;
				$$->nextpipe = $3;

				/* Check for invalid redirects inside pipes */
				if(strcmp($1->outfile, "<undirected>") != 0)
				{
					yyerror("Cannot redirect output inside a pipe");
				}

				if(strcmp($3->infile, "<undirected>") != 0)
				{
					yyerror("Cannot redirect input inside a pipe");
				}
			}
  		;

variable	: WORD
				{
					char *var = $1;
					strcat(var, "=");
					strcat(var, mygetenv($1));
					AssignVar(var);
					$$ = var;
				}
			| assignment
				{
					$$ = $1;
				}
			;

assignment	: VAR
				{
					AssignVar($1);
					$$ = $1;
				}
			| VAREXPAND
				{
					if (DEBUG == 1) printf("VarExpand : %s\n", VarExpand($1));
					AssignVar(VarExpand($1));
					$$ = $1;
				}
			| VAR args
				{
					yyerror("Cannot put arguments after variable assignment!!");
				}
			| VAREXPAND args
				{
					yyerror("Cannot put arguments after variable assignment!!");
				}
			;

chdir	: CD
			{
				if (chdir(vars[0].value) != 0)		// vars[0].name = "HOME"
				{
					yyerror("Could not go to home directory");
				}
			}
		| CD WORD
			{
				if (chdir(VarExpand($2)) != 0)
				{
					yyerror("Invalid directory : %s\n", VarExpand($2));
				}
			}
		| CD WORD args
			{
				yyerror("Multiple args for cd is not allowed!!");
			}
		;

metacmdlist : metacmd eoln metacmdlist
				{
					$$ = (struct metacmdlist *) malloc(sizeof(struct metacmdlist));
					$$->metacmd = $1;
					$$->next = $3;
				}
			| 
				{
					$$ = NULL;
				}
			;

metacmd	: cmd
			{
				if (DEBUG == 1) printf("im in metacmd : cmd\n");
				$$ = (struct metacmd *) malloc(sizeof(struct metacmd));
				$$->cmd = $1;
				$$->whileloop = NULL;
				$$->forloop = NULL;
				$$->var_assign = NULL;
			}
		| whileloop
			{
				if (DEBUG == 1) printf("im in metacmd : whileloop\n");
				$$ = (struct metacmd *) malloc(sizeof(struct metacmd));
				$$->cmd = NULL;
				$$->whileloop = $1;
				$$->forloop = NULL;
				$$->var_assign = NULL;
			}
		| forloop
			{
				if (DEBUG == 1) printf("im in metacmd : forloop\n");
				$$ = (struct metacmd *) malloc(sizeof(struct metacmd));
				$$->cmd = NULL;
				$$->whileloop = NULL;
				$$->forloop = $1;
				$$->var_assign = NULL;
			}
		| assignment
			{
				if (DEBUG == 1) printf("im in metacmd : assignment\n");
				$$ = (struct metacmd *) malloc(sizeof(struct metacmd));
				$$->cmd = NULL;
				$$->whileloop = NULL;
				$$->forloop = NULL;
				$$->var_assign = $1;
			}
		;

cmd		: WORD args optredir
			{
				/* Store the command and args inside command struct */
				$$ = (struct command *) malloc(sizeof(struct command));
				$$->command = VarExpand($1);
				$$->pargs = $2;
				if ($1[0] == '/')
				{
					$$->abs_path = 1;
				}
				else
				{
					$$->abs_path = 0;
				}

				/* Get the length of the args linked list into argc */
				struct args *current = (struct args*) malloc(sizeof(struct args));
				current = $2;
				int args_len = 1;
				while(current != NULL)
				{
					if (args_len <= MAX_ARGS)
					{
						args_len++;
						current = current->next;
					}
					else
					{
						yyerror("Too many args!!");
						break;
					}
				}
				$$->argc = args_len;

				/* Only check for io redirection if there is any */
				if($3 != NULL)
				{
					/* Check for valid redirects */
					check_ioredir($3);

					/* Use a temporary pointer to an io_redir object to load data into command */
					struct io_redir *temp = (struct io_redir*) malloc(sizeof(struct io_redir));
					
					/* Infile */
					temp = find_iofile($3, 0);
					if(temp == NULL)
					{
						$$->infile = "<undirected>";
					}
					else
					{
						$$->infile = temp->file;
					}

					/* Outfile */
					temp = find_iofile($3, 1);
					if(temp == NULL)
					{
						/* Check for output append */
						temp = find_iofile($3, 2);
						if(temp == NULL)
						{
							$$->outfile = "<undirected>";
						}
						else
						{
							$$->outfile = temp->file;
							$$->output_append = 1;
						}
					}
					else
					{
						$$->outfile = temp->file;
						$$->output_append = 0;
					}

					/* Errfile */
					temp = find_iofile($3, 3);
					if(temp == NULL)
					{
						/* Check for error append */
						temp = find_iofile($3, 4);
						if(temp == NULL)
						{
							$$->errfile = "<undirected>";
						}
						else
						{
							$$->errfile = temp->file;
							$$->error_append = 1;
						}
					}
					else
					{
						$$->errfile = temp->file;
						$$->error_append = 0;
					}
				}
				else
				{
					$$->infile = "<undirected>";
					$$->outfile = "<undirected>";
					$$->errfile = "<undirected>";
					$$->output_append = 0;
					$$->error_append = 0;
				}
			}
		| WORD args optredir cmd
			{
				yyerror("Cannot include arguments past the optional i/o redirection");
			}
		;

args	: arg args
			{
				$$ = (struct args *) malloc(sizeof(struct args));
				$$->arg = $1;
				$$->next = $2;
			}
		|
			{ 
				$$ = NULL;
			}
		;

arg		: WORD
			{
				$$ = VarExpand($1);
			}
		;

optredir 	: INPUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 0;
					$$->file = VarExpand($2);
					$$->next = $3;
				}
			| OUTPUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 1;
					$$->file = VarExpand($2);
					$$->next = $3;
				}
			| OUTPUT_APPEND WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 2;
					$$->file = VarExpand($2);
					$$->next = $3;
				}
			| ERROUT WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 3;
					$$->file = VarExpand($2);
					$$->next = $3;
				}
			| ERROUT_APPEND WORD optredir
				{
					$$ = (struct io_redir *) malloc(sizeof(struct io_redir));
					$$->redir_type = 4;
					$$->file = VarExpand($2);
					$$->next = $3;
				}
			|
				{
					$$ = NULL;
				}
			;

%%

void yyerror(const char *error_string, ...) {
    va_list ap;
    int line_nmb(void);

    FILE *f = stdout;

    va_start(ap,error_string);

    ++synerrors;
	++errorflag;
	// fprintf(f, "synerrors = %d\n", synerrors);
    fprintf(f,"Error on line %d: ", lines);
    vfprintf(f,error_string,ap);
    fprintf(f,"\n");
    va_end(ap);
}

void check_ioredir(struct io_redir *optredir){
	/// Check the linked list for invalid redirects, if there are then raise an error
	struct io_redir *current = (struct io_redir *) malloc(sizeof(struct io_redir));
	current = optredir;
	int inflag = 0;
	int outflag = 0;
	int errflag = 0;	
	while(current != NULL)
	{
		if(inflag == 0 && current->redir_type == 0)
		{
			inflag = 1;
		}
		else if(current->redir_type == 0)
		{
			yyerror("Too many input redirects!");
		}

		if(outflag == 0 && (current->redir_type == 1 || current->redir_type == 2))
		{
			outflag = 1;
		}
		else if(current->redir_type == 1 || current->redir_type == 2)
		{
			yyerror("Too many output redirects!!");
		}

		if(errflag == 0 && (current->redir_type == 3 || current->redir_type == 4))
		{
			errflag = 1;
		}
		else if(current->redir_type == 3 || current->redir_type == 4)
		{
			yyerror("Too many error redirects!!!");
		}

		current = current->next;
	}
}

struct io_redir *find_iofile(struct io_redir *optredir, int type){
	/// Walk through the linked list searching for the given type of redirect
	struct io_redir *current = (struct io_redir *) malloc(sizeof(struct io_redir));
	current = optredir;
	while(current != NULL)
	{
		if(current->redir_type == type)
		{
			return(current);
		}
		current = current->next;
	}
	return(NULL);
}

void AssignVar(char *string){
	string = DelQuotes(string);
	char *substr = (char*)malloc(6);
	/// Check for PATH special case
	if (strlen(string) > 5)
	{
		memcpy(substr, string, 5);
	}
	if (DEBUG == 1) printf("substr : %s\n", substr);
	if (strcmp(substr, "PATH=") == 0)
	{
		int path_count = 1;         //number of tokens stored in path variable, separated by colons
		for (int i = 0; i < strlen(string); i++)
		{
			if (string[i] == ':')
			{
				if (path_count <= MAX_PATHS)
				{
					path_count++;
				}
				else
				{
					yyerror("Number of paths exceeds MAX_PATHS");
					break;
				}
			}
		}
	}

	/// Check for DEBUG special case
	if (strlen(string) > 6)
	{
		memcpy(substr, string, 6);
	}
	if (DEBUG == 1) printf("substr : %s\n", substr);
	if (strcmp(string, "DEBUG=") == 0)
	{
		DEBUG = 0;
	}
	else if (strlen(string) > 6 && strcmp(substr, "DEBUG=") == 0)
	{
		DEBUG = 1;
	}

	/// Separate variable into its name and value
	char *name = (char*)malloc(strlen(string));
	char *value = (char*)malloc(strlen(string));
	for (int i = 0; i < strlen(string); i++)
	{
		if (string[i] == '=')
		{
			memcpy(name, string, i);
			for (int j = i + 1; j < strlen(string); j++)
			{
				value[j - i - 1] = string[j];
			}
			break;
		}
	}

	/// Put variable into global array, if not already there, reassign if it is already there
	int isthere = 0;
	for (int i = 0; i < NEXT_OPEN_SPOT; i++)
	{
		if (DEBUG == 1) printf("vars[%d] : %s ?= %s\n", i, vars[i].name, name);
		if (strcmp(vars[i].name, name) == 0)
		{
			vars[i].value = value;
			isthere = 1;
			if (vars[i].is_exported == 1) putenv(string);
			break;
		}
	}
	if (isthere == 0 && NEXT_OPEN_SPOT < MAX_VARS)
	{
		vars[NEXT_OPEN_SPOT].name = name;
		vars[NEXT_OPEN_SPOT].value = value;
		vars[NEXT_OPEN_SPOT].is_exported = 0;
		NEXT_OPEN_SPOT++;
	}
	else if (NEXT_OPEN_SPOT == MAX_VARS)
	{
		yyerror("Maximum number of variables has been reached");
	}
}

void Prompt(){
	if (vars[1].value != NULL)
	{	// vars[1].name = "PROMPT"
		if (isatty(0) == 1) printf("%s", vars[1].value);
		// fflush(stdout);
	}
}

char *DelQuotes(char *string){
	if (DEBUG == 1) printf("I'm in DelQuotes %s\n", string);
	for (int i = 0; i < strlen(string); i++)
	{
		if (string[i] == '\'' || string[i] == '\"')
		{
			for (int j = i; j < strlen(string) - 1; j++)
			{
				string[j] = string[j + 1];
			}
			string[strlen(string) - 2] = 0;
			break;
		}
	}
	if (DEBUG == 1) printf("string : %s\n", string);
	return string;
}

char *VarExpand(char *string){
	/// Check for single quotes
	// printf("string : %s\n", string);
	if (string[strlen(string) - 1] == '\'') return DelQuotes(string);
	int has_quotes = 0;
	for (int i = 0; i < strlen(string) - 1; i++)
	{
		if (string[i] == '\'')
		{
			has_quotes = 1;
			break;
		}
		else if (string[i] == '"')
		{
			break;
		}
	}
	if (has_quotes == 1) return DelQuotes(string);

	// printf("VarExpand string1 : %s\n", string);
	string = DelQuotes(string);
	// printf("VarExpand string2 : %s\n", string);
	char *result = (char*)malloc(strlen(string));
	int char_diff = 0;
    for (int i = 0; i < strlen(string); i++)
    {
		if (DEBUG == 1) printf("char_diff : %d\n", char_diff);
        if (string[i] == '$')
		{
			if (DEBUG == 1) printf("string[%d] = $\n", i);
			char *var = (char*)malloc(strlen(string));
			if (string[i + 1] == '{')
			{	/// Look for variable name inside brackets
				int j = i + 2;
				for (; j < strlen(string); j++)
				{
					if (string[j] == '}' || string[j] == '#' || string[j] == '%')
					{
						/// Logic for excluding patterns with # and %
						char *pattern = (char*)malloc(strlen(string));
						int num_symbols = 0;
						int beg_pattern = 0;
						int end_pattern = 0;
						if (string[j] == '#')
						{
							int k = j + 1;
							num_symbols += 1;
							beg_pattern += 1;
							if (string[j + 1] == '#')
							{
								k += 1;
								num_symbols += 1;
							}
							for (; k < strlen(string); k++)
							{
								if (string[k] == '}') 
								{
									if (string[k + 1] == '}') pattern[k - j - num_symbols] = '}';
									break;
								}
								else pattern[k - j - num_symbols] = string[k];
							}
						}
						else if (string[j] == '%')
						{
							int k = j + 1;
							num_symbols += 1;
							end_pattern += 1;
							if (string[j + 1] == '%')
							{
								k += 1;
								num_symbols += 1;
							}
							for (; k < strlen(string); k++)
							{
								if (string[k] == '}')
								{
									if (string[k + 1] == '}') pattern[k - j - num_symbols] = '}';
									break;
								}
								else pattern[k - j - num_symbols] = string[k];
							}
						}
						if (DEBUG == 1) printf("pattern : %s\n", pattern);

						char *temp = mygetenv(var);
						char *value = (char *) malloc(strlen(string));
						if (DEBUG == 1) printf("test!!!!!!!!\n");
						if (temp != NULL)
						{
							memcpy(value, temp, strlen(temp));		//copy the actual variable value
						}
						else
						{
							value = NULL;
						}

						if (DEBUG == 1) printf("var : %s\n", var);
						if (DEBUG == 1) printf("var value : %s\n", value);
						/// If there was a pattern, need to remove it from the beginning or end
						if (strlen(pattern) != 0)
						{
							char *temp2 = VarExpand(pattern);
							if (temp2 != NULL)
							{
								pattern = realloc(pattern, strlen(temp2));
								memcpy(pattern, temp2, strlen(temp2));
							}
							if (DEBUG == 1) printf("pattern (expanded) : %s\n", pattern);

							int pattern_match = 1;
							if (beg_pattern == 1)
							{
								for (int k = 0; k < strlen(pattern); k++)
								{
									if (pattern[k] != value[k])
									{
										pattern_match = 0;
										break;
									}
								}
								if (pattern_match == 1) value += strlen(pattern);
							}
							else if (end_pattern == 1)
							{
								for (int k = strlen(pattern) - 1, l = strlen(value) - 1; k >= 0; k--, l--)
								{
									if (DEBUG == 1) printf("pattern[%d] : %c, value[%d] : %c\n", k, pattern[k], l, value[l]);
									if (pattern[k] != value[l])
									{
										pattern_match = 0;
										break;
									}
								}
								if (pattern_match == 1) value[strlen(value) - strlen(pattern)] = 0;
							}
						}

						if (value != NULL)
						{
							/// Resize result to take into account difference of size of ${VARIABLE} and its value
							result = realloc(result, strlen(string) + strlen(value) - 3 - num_symbols - strlen(var));
							for (int k = 0; k < strlen(value); k++)
							{
								result[k + i + char_diff] = value[k];
							}
							char_diff += strlen(value) - 3 - num_symbols - strlen(var);
							i += 2 + num_symbols + strlen(var) + strlen(pattern);
							break;
						}
						else
						{
							result[i + char_diff] = string[i];
							break;
						}
					}
					else
					{
						var[j - i - 2] = string[j];
					}
				}
				if (j == strlen(string))
				{
					yyerror("Braces not paired correctly");
				}
			}
			else
			{	/// Look for illegal chars to the right of the variable name
				for (int j = i + 1; j < strlen(string) + 1; j++)
				{
					if (isalpha(string[j]) == 0 && isdigit(string[j]) == 0 && string[j] != '_')
					{
						char *value = mygetenv(var);
						if (DEBUG == 1) printf("var : %s\n", var);
						if (DEBUG == 1) printf("var value : %s\n", value);
						if (value != NULL)
						{
							/// Resize result to take into account difference of size of $VARIABLE and its value
							result = realloc(result, strlen(string) + strlen(value) - 3 - strlen(var));
							for (int k = 0; k < strlen(value); k++)
							{
								result[k + i + char_diff] = value[k];
							}
							char_diff += strlen(value) - 1 - strlen(var);
							i += strlen(var);
							break;
						}
						else
						{
							result[i + char_diff] = string[i];
							break;
						}
					}
					else
					{
						var[j - i - 1] = string[j];
					}
				}
			}
		}
		else
		{
			result[i + char_diff] = string[i];
		}
    }
	return result;
}

char *mygetenv(char *name){
	if (DEBUG  == 1) printf("NEXT_OPEN_SPOT : %d\n", NEXT_OPEN_SPOT);
	for (int i = 0; i < NEXT_OPEN_SPOT; i++)
	{
		if (DEBUG  == 1) printf("vars[%d] : %s = %s\n", i, vars[i].name, vars[i].value);
		if (strcmp(vars[i].name, name) == 0)
		{
			return vars[i].value;
		}
	}
	/// Check the environment if its not in global array
	if (getenv(name) == NULL)
	{
		return NULL;
	}
	else
	{
		return getenv(name);
	}
}

void doForLoop(struct loopfor *myfor){
	/// Get the number of args
	struct args *current_arg = (struct args*) malloc(sizeof(struct args));
	current_arg = myfor->loopargs->next;
	int num_args = 1;
	while(current_arg != NULL)
	{
		if (num_args <= MAX_ARGS)
		{
			num_args++;
			current_arg = current_arg->next;
		}
		else
		{
			yyerror("Too many args!!");
			break;
		}
	}

	current_arg = myfor->loopargs;
	char *variable = (char *) malloc(strlen(myfor->variable));
	struct metacmdlist *current_cmd = (struct metacmdlist*) malloc(sizeof(struct metacmdlist));
	current_cmd = myfor->body;
	/// Do the loop
	for (int i = 0; i < num_args; i++)
	{
		/// Reassign the variable each time to the next arg
		memcpy(variable, myfor->variable, strlen(myfor->variable));
		variable = realloc(variable, 1 + strlen(current_arg->arg));
		strcat(variable, "=");
		strcat(variable, current_arg->arg);
		if (DEBUG == 1) printf("for var : %s\n", variable);
		AssignVar(variable);
		if (DEBUG == 1) printf("%s = %s\n", myfor->variable, mygetenv(myfor->variable));
		
		/// Do the command list
		while (current_cmd != NULL)
		{
			if (current_cmd->metacmd->cmd != NULL)
			{
				if (DEBUG == 1) printf("it's a command\n");
				struct command *cmdcpy = (struct command*) malloc(sizeof(struct command));
				memcpy(cmdcpy, current_cmd->metacmd->cmd, sizeof(struct command));
				cmdcpy->command = VarExpand2(cmdcpy->command);
				struct args *current = (struct args*) malloc(sizeof(struct args));
				memcpy(current, cmdcpy->pargs, sizeof(struct args));
				cmdcpy->pargs = current;
				while (current != NULL)
				{
					if (DEBUG == 1) printf("current1 = %s\n", current->arg);
					current->arg = VarExpand2(current->arg);
					if (DEBUG == 1) printf("current2 = %s\n", current->arg);
					// current->next = (struct args*) malloc(sizeof(struct args));
					current = current->next;
				}
				int temp = 0;
				doline(cmdcpy, lines, errorflag, DEBUG, &temp);
			}
			else if (current_cmd->metacmd->forloop != NULL)
			{
				if (DEBUG == 1) printf("it's a for loop\n");
				doForLoop(current_cmd->metacmd->forloop);
			}
			else if (current_cmd->metacmd->whileloop != NULL)
			{
				if (DEBUG == 1) printf("it's a while loop\n");
				doWhileLoop(current_cmd->metacmd->whileloop);
			}
			else if (current_cmd->metacmd->var_assign != NULL)
			{
				if (DEBUG == 1) printf("it's a var assign\n");
				printf("string : %s\n", current_cmd->metacmd->var_assign);
				AssignVar(VarExpand2(current_cmd->metacmd->var_assign));
			}
			current_cmd = current_cmd->next;
		}

		/// Reset variable, current_cmd, and increment the arg
		memset(variable, 0, strlen(variable));
		current_cmd = myfor->body;
		current_arg = current_arg->next;
	}
}

void doWhileLoop(struct loopwhile *mywhile){
	/// Check condition first
	int temp = 0;
	if (DEBUG == 1) printf("exec_fail : %d\n", temp);
	doline(mywhile->condition, lines, errorflag, DEBUG, &temp);
	if (DEBUG == 1) printf("exec_fail : %d\n", temp);

	/// Get a pointer to a metacmd so we can walk through the linked list
	struct metacmdlist *current_cmd = (struct metacmdlist*) malloc(sizeof(struct metacmdlist));
	
	/// Run while loop until condition fails
	while (temp != 1)
	{
		/// Do the command list
		current_cmd = mywhile->body;
		while (current_cmd != NULL)
		{
			if (current_cmd->metacmd->cmd != NULL)
			{
				if (DEBUG == 1) printf("it's a command\n");
				struct command *cmdcpy = (struct command*) malloc(sizeof(struct command));
				memcpy(cmdcpy, current_cmd->metacmd->cmd, sizeof(struct command));
				cmdcpy->command = VarExpand2(cmdcpy->command);
				struct args *current = (struct args*) malloc(sizeof(struct args));
				memcpy(current, cmdcpy->pargs, sizeof(struct args));
				cmdcpy->pargs = current;
				while (current != NULL)
				{
					if (DEBUG == 1) printf("current1 = %s\n", current->arg);
					current->arg = VarExpand2(current->arg);
					if (DEBUG == 1) printf("current2 = %s\n", current->arg);
					// current->next = (struct args*) malloc(sizeof(struct args));
					current = current->next;
				}
				int temp = 0;
				doline(cmdcpy, lines, errorflag, DEBUG, &temp);
			}
			else if (current_cmd->metacmd->forloop != NULL)
			{
				if (DEBUG == 1) printf("it's a for loop\n");
				doForLoop(current_cmd->metacmd->forloop);
			}
			else if (current_cmd->metacmd->whileloop != NULL)
			{
				if (DEBUG == 1) printf("it's a while loop\n");
				doWhileLoop(current_cmd->metacmd->whileloop);
			}
			else if (current_cmd->metacmd->var_assign != NULL)
			{
				if (DEBUG == 1) printf("it's a var assign\n");
				printf("string : %s\n", current_cmd->metacmd->var_assign);
				AssignVar(VarExpand2(current_cmd->metacmd->var_assign));
			}
			current_cmd = current_cmd->next;
		}

		/// Check the condition again
		doline(mywhile->condition, lines, errorflag, DEBUG, &temp);
	}
}

char *VarExpand2(char *string){
	char *result = (char*)malloc(strlen(string));
	int char_diff = 0;
    for (int i = 0; i < strlen(string); i++)
    {
		if (DEBUG == 1) printf("char_diff : %d\n", char_diff);
        if (string[i] == '$')
		{
			if (DEBUG == 1) printf("string[%d] = $\n", i);
			char *var = (char*)malloc(strlen(string));
			if (string[i + 1] == '{')
			{	/// Look for variable name inside brackets
				int j = i + 2;
				for (; j < strlen(string); j++)
				{
					if (string[j] == '}' || string[j] == '#' || string[j] == '%')
					{
						/// Logic for excluding patterns with # and %
						char *pattern = (char*)malloc(strlen(string));
						int num_symbols = 0;
						int beg_pattern = 0;
						int end_pattern = 0;
						if (string[j] == '#')
						{
							int k = j + 1;
							num_symbols += 1;
							beg_pattern += 1;
							if (string[j + 1] == '#')
							{
								k += 1;
								num_symbols += 1;
							}
							for (; k < strlen(string); k++)
							{
								if (string[k] == '}') 
								{
									if (string[k + 1] == '}') pattern[k - j - num_symbols] = '}';
									break;
								}
								else pattern[k - j - num_symbols] = string[k];
							}
						}
						else if (string[j] == '%')
						{
							int k = j + 1;
							num_symbols += 1;
							end_pattern += 1;
							if (string[j + 1] == '%')
							{
								k += 1;
								num_symbols += 1;
							}
							for (; k < strlen(string); k++)
							{
								if (string[k] == '}')
								{
									if (string[k + 1] == '}') pattern[k - j - num_symbols] = '}';
									break;
								}
								else pattern[k - j - num_symbols] = string[k];
							}
						}
						if (DEBUG == 1) printf("pattern : %s\n", pattern);

						char *temp = mygetenv(var);
						char *value = (char *) malloc(strlen(string));
						if (DEBUG == 1) printf("test!!!!!!!!\n");
						if (temp != NULL)
						{
							memcpy(value, temp, strlen(temp));		//copy the actual variable value
						}
						else
						{
							value = NULL;
						}

						if (DEBUG == 1) printf("var : %s\n", var);
						if (DEBUG == 1) printf("var value : %s\n", value);
						/// If there was a pattern, need to remove it from the beginning or end
						if (strlen(pattern) != 0)
						{
							char *temp2 = VarExpand(pattern);
							if (temp2 != NULL)
							{
								pattern = realloc(pattern, strlen(temp2));
								memcpy(pattern, temp2, strlen(temp2));
							}
							if (DEBUG == 1) printf("pattern (expanded) : %s\n", pattern);

							int pattern_match = 1;
							if (beg_pattern == 1)
							{
								for (int k = 0; k < strlen(pattern); k++)
								{
									if (pattern[k] != value[k])
									{
										pattern_match = 0;
										break;
									}
								}
								if (pattern_match == 1) value += strlen(pattern);
							}
							else if (end_pattern == 1)
							{
								for (int k = strlen(pattern) - 1, l = strlen(value) - 1; k >= 0; k--, l--)
								{
									if (DEBUG == 1) printf("pattern[%d] : %c, value[%d] : %c\n", k, pattern[k], l, value[l]);
									if (pattern[k] != value[l])
									{
										pattern_match = 0;
										break;
									}
								}
								if (pattern_match == 1) value[strlen(value) - strlen(pattern)] = 0;
							}
						}

						if (value != NULL)
						{
							/// Resize result to take into account difference of size of ${VARIABLE} and its value
							result = realloc(result, strlen(string) + strlen(value) - 3 - num_symbols - strlen(var));
							for (int k = 0; k < strlen(value); k++)
							{
								result[k + i + char_diff] = value[k];
							}
							char_diff += strlen(value) - 3 - num_symbols - strlen(var);
							i += 2 + num_symbols + strlen(var) + strlen(pattern);
							break;
						}
						else
						{
							result[i + char_diff] = string[i];
							break;
						}
					}
					else
					{
						var[j - i - 2] = string[j];
					}
				}
				if (j == strlen(string))
				{
					yyerror("Braces not paired correctly");
				}
			}
			else
			{	/// Look for illegal chars to the right of the variable name
				for (int j = i + 1; j < strlen(string) + 1; j++)
				{
					if (isalpha(string[j]) == 0 && isdigit(string[j]) == 0 && string[j] != '_')
					{
						char *value = mygetenv(var);
						if (DEBUG == 1) printf("var : %s\n", var);
						if (DEBUG == 1) printf("var value : %s\n", value);
						if (value != NULL)
						{
							/// Resize result to take into account difference of size of $VARIABLE and its value
							result = realloc(result, strlen(string) + strlen(value) - 3 - strlen(var));
							for (int k = 0; k < strlen(value); k++)
							{
								result[k + i + char_diff] = value[k];
							}
							char_diff += strlen(value) - 1 - strlen(var);
							i += strlen(var);
							break;
						}
						else
						{
							result[i + char_diff] = string[i];
							break;
						}
					}
					else
					{
						var[j - i - 1] = string[j];
					}
				}
			}
		}
		else
		{
			result[i + char_diff] = string[i];
		}
    }
	return result;
}